/// <reference types="node" />
/// <reference types="node" />
import { Duplex, Readable, Stream, Transform, TransformCallback } from 'node:stream';
export declare const forwardStreamErrors: (...streams: Stream[]) => void;
export declare const cloneStream: (stream: Readable) => Readable;
export declare const streamSize: (stream: Readable) => Promise<number>;
export declare const streamToBytes: (stream: AsyncIterable<Uint8Array>) => Promise<Uint8Array>;
export declare const streamToNodeBuffer: (stream: Iterable<Uint8Array> | AsyncIterable<Uint8Array>) => Promise<Buffer>;
export declare const byteIterableToStream: (iter: AsyncIterable<Uint8Array>) => Readable;
export declare const bytesToStream: (bytes: Uint8Array) => Readable;
export declare class MaxSizeChecker extends Transform {
    maxSize: number;
    createError: () => Error;
    totalSize: number;
    constructor(maxSize: number, createError: () => Error);
    _transform(chunk: Uint8Array, _enc: BufferEncoding, cb: TransformCallback): void;
}
export declare function decodeStream(stream: Readable, contentEncoding?: string | string[]): Readable;
export declare function decodeStream(stream: AsyncIterable<Uint8Array>, contentEncoding?: string | string[]): AsyncIterable<Uint8Array> | Readable;
/**
 * Create a series of decoding streams based on the content-encoding header. The
 * resulting streams should be piped together to decode the content.
 *
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9110#section-8.4.1}
 */
export declare function createDecoders(contentEncoding?: string | string[]): Duplex[];
//# sourceMappingURL=streams.d.ts.map