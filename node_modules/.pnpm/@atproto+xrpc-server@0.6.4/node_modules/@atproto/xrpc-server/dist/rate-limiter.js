"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTightestLimit = exports.setResHeaders = exports.consumeMany = exports.formatLimiterStatus = exports.RateLimiter = void 0;
const rate_limiter_flexible_1 = require("rate-limiter-flexible");
const logger_1 = require("./logger");
const types_1 = require("./types");
class RateLimiter {
    constructor(limiter, opts) {
        Object.defineProperty(this, "limiter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bypassSecret", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bypassIps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "failClosed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "calcKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "calcPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.limiter = limiter;
        this.bypassSecret = opts.bypassSecret;
        this.bypassIps = opts.bypassIps;
        this.calcKey = opts.calcKey ?? defaultKey;
        this.calcPoints = opts.calcPoints ?? defaultPoints;
    }
    static memory(opts) {
        const limiter = new rate_limiter_flexible_1.RateLimiterMemory({
            keyPrefix: opts.keyPrefix,
            duration: Math.floor(opts.durationMs / 1000),
            points: opts.points,
        });
        return new RateLimiter(limiter, opts);
    }
    static redis(storeClient, opts) {
        const limiter = new rate_limiter_flexible_1.RateLimiterRedis({
            storeClient,
            keyPrefix: opts.keyPrefix,
            duration: Math.floor(opts.durationMs / 1000),
            points: opts.points,
        });
        return new RateLimiter(limiter, opts);
    }
    async consume(ctx, opts) {
        if (this.bypassSecret &&
            ctx.req.header('x-ratelimit-bypass') === this.bypassSecret) {
            return null;
        }
        if (this.bypassIps && this.bypassIps.includes(ctx.req.ip)) {
            return null;
        }
        const key = opts?.calcKey ? opts.calcKey(ctx) : this.calcKey(ctx);
        if (key === null) {
            return null;
        }
        const points = opts?.calcPoints
            ? opts.calcPoints(ctx)
            : this.calcPoints(ctx);
        if (points < 1) {
            return null;
        }
        try {
            const res = await this.limiter.consume(key, points);
            return (0, exports.formatLimiterStatus)(this.limiter, res);
        }
        catch (err) {
            // yes this library rejects with a res not an error
            if (err instanceof rate_limiter_flexible_1.RateLimiterRes) {
                const status = (0, exports.formatLimiterStatus)(this.limiter, err);
                return new types_1.RateLimitExceededError(status);
            }
            else {
                if (this.failClosed) {
                    throw err;
                }
                logger_1.logger.error({
                    err,
                    keyPrefix: this.limiter.keyPrefix,
                    points: this.limiter.points,
                    duration: this.limiter.duration,
                }, 'rate limiter failed to consume points');
                return null;
            }
        }
    }
}
exports.RateLimiter = RateLimiter;
const formatLimiterStatus = (limiter, res) => {
    return {
        limit: limiter.points,
        duration: limiter.duration,
        remainingPoints: res.remainingPoints,
        msBeforeNext: res.msBeforeNext,
        consumedPoints: res.consumedPoints,
        isFirstInDuration: res.isFirstInDuration,
    };
};
exports.formatLimiterStatus = formatLimiterStatus;
const consumeMany = async (ctx, fns) => {
    if (fns.length === 0)
        return null;
    const results = await Promise.all(fns.map((fn) => fn(ctx)));
    const tightestLimit = (0, exports.getTightestLimit)(results);
    if (tightestLimit === null) {
        return null;
    }
    else if (tightestLimit instanceof types_1.RateLimitExceededError) {
        (0, exports.setResHeaders)(ctx, tightestLimit.status);
        return tightestLimit;
    }
    else {
        (0, exports.setResHeaders)(ctx, tightestLimit);
        return tightestLimit;
    }
};
exports.consumeMany = consumeMany;
const setResHeaders = (ctx, status) => {
    ctx.res.setHeader('RateLimit-Limit', status.limit);
    ctx.res.setHeader('RateLimit-Remaining', status.remainingPoints);
    ctx.res.setHeader('RateLimit-Reset', Math.floor((Date.now() + status.msBeforeNext) / 1000));
    ctx.res.setHeader('RateLimit-Policy', `${status.limit};w=${status.duration}`);
};
exports.setResHeaders = setResHeaders;
const getTightestLimit = (resps) => {
    let lowest = null;
    for (const resp of resps) {
        if (resp === null)
            continue;
        if (resp instanceof types_1.RateLimitExceededError)
            return resp;
        if (lowest === null || resp.remainingPoints < lowest.remainingPoints) {
            lowest = resp;
        }
    }
    return lowest;
};
exports.getTightestLimit = getTightestLimit;
// when using a proxy, ensure headers are getting forwarded correctly: `app.set('trust proxy', true)`
// https://expressjs.com/en/guide/behind-proxies.html
const defaultKey = (ctx) => ctx.req.ip;
const defaultPoints = () => 1;
//# sourceMappingURL=rate-limiter.js.map