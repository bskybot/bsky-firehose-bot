"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodNotImplementedError = exports.UpstreamTimeoutError = exports.NotEnoughResourcesError = exports.UpstreamFailureError = exports.InternalServerError = exports.RateLimitExceededError = exports.ForbiddenError = exports.AuthRequiredError = exports.InvalidRequestError = exports.isHandlerError = exports.XRPCError = exports.isShared = exports.handlerError = exports.handlerPipeThrough = exports.handlerSuccess = exports.handlerAuth = exports.handlerInput = void 0;
const http_errors_1 = require("http-errors");
const zod_1 = __importDefault(require("zod"));
const xrpc_1 = require("@atproto/xrpc");
exports.handlerInput = zod_1.default.object({
    encoding: zod_1.default.string(),
    body: zod_1.default.any(),
});
exports.handlerAuth = zod_1.default.object({
    credentials: zod_1.default.any(),
    artifacts: zod_1.default.any(),
});
exports.handlerSuccess = zod_1.default.object({
    encoding: zod_1.default.string(),
    body: zod_1.default.any(),
    headers: zod_1.default.record(zod_1.default.string()).optional(),
});
exports.handlerPipeThrough = zod_1.default.object({
    encoding: zod_1.default.string(),
    buffer: zod_1.default.instanceof(ArrayBuffer),
    headers: zod_1.default.record(zod_1.default.string()).optional(),
});
exports.handlerError = zod_1.default.object({
    status: zod_1.default.number(),
    error: zod_1.default.string().optional(),
    message: zod_1.default.string().optional(),
});
const isShared = (opts) => {
    return typeof opts['name'] === 'string';
};
exports.isShared = isShared;
class XRPCError extends Error {
    constructor(type, errorMessage, customErrorName) {
        super(errorMessage);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "errorMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errorMessage
        });
        Object.defineProperty(this, "customErrorName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: customErrorName
        });
    }
    get payload() {
        return {
            error: this.customErrorName ?? this.typeName,
            message: this.type === xrpc_1.ResponseType.InternalServerError
                ? this.typeStr // Do not respond with error details for 500s
                : this.errorMessage || this.typeStr,
        };
    }
    get typeName() {
        return xrpc_1.ResponseTypeNames[this.type];
    }
    get typeStr() {
        return xrpc_1.ResponseTypeStrings[this.type];
    }
    static fromError(error) {
        if (error instanceof XRPCError) {
            return error;
        }
        let resultErr;
        if ((0, http_errors_1.isHttpError)(error)) {
            resultErr = new XRPCError(error.status, error.message, error.name);
        }
        else if (isHandlerError(error)) {
            resultErr = new XRPCError(error.status, error.message, error.error);
        }
        else if (error instanceof Error) {
            resultErr = new InternalServerError(error.message);
        }
        else {
            resultErr = new InternalServerError('Unexpected internal server error');
        }
        resultErr.cause = error;
        return resultErr;
    }
}
exports.XRPCError = XRPCError;
function isHandlerError(v) {
    return (!!v &&
        typeof v === 'object' &&
        typeof v['status'] === 'number' &&
        (v['error'] === undefined || typeof v['error'] === 'string') &&
        (v['message'] === undefined || typeof v['message'] === 'string'));
}
exports.isHandlerError = isHandlerError;
class InvalidRequestError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.InvalidRequest, errorMessage, customErrorName);
    }
}
exports.InvalidRequestError = InvalidRequestError;
class AuthRequiredError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.AuthRequired, errorMessage, customErrorName);
    }
}
exports.AuthRequiredError = AuthRequiredError;
class ForbiddenError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.Forbidden, errorMessage, customErrorName);
    }
}
exports.ForbiddenError = ForbiddenError;
class RateLimitExceededError extends XRPCError {
    constructor(status, errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.RateLimitExceeded, errorMessage, customErrorName);
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: status
        });
    }
}
exports.RateLimitExceededError = RateLimitExceededError;
class InternalServerError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.InternalServerError, errorMessage, customErrorName);
    }
}
exports.InternalServerError = InternalServerError;
class UpstreamFailureError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.UpstreamFailure, errorMessage, customErrorName);
    }
}
exports.UpstreamFailureError = UpstreamFailureError;
class NotEnoughResourcesError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.NotEnoughResources, errorMessage, customErrorName);
    }
}
exports.NotEnoughResourcesError = NotEnoughResourcesError;
class UpstreamTimeoutError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.UpstreamTimeout, errorMessage, customErrorName);
    }
}
exports.UpstreamTimeoutError = UpstreamTimeoutError;
class MethodNotImplementedError extends XRPCError {
    constructor(errorMessage, customErrorName) {
        super(xrpc_1.ResponseType.MethodNotImplemented, errorMessage, customErrorName);
    }
}
exports.MethodNotImplementedError = MethodNotImplementedError;
//# sourceMappingURL=types.js.map