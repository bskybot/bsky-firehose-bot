"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyJwt = exports.createServiceAuthHeaders = exports.createServiceJwt = void 0;
const common = __importStar(require("@atproto/common"));
const common_1 = require("@atproto/common");
const crypto = __importStar(require("@atproto/crypto"));
const ui8 = __importStar(require("uint8arrays"));
const types_1 = require("./types");
const createServiceJwt = async (params) => {
    const { iss, aud, keypair } = params;
    const iat = params.iat ?? Math.floor(Date.now() / 1e3);
    const exp = params.exp ?? iat + common_1.MINUTE / 1e3;
    const lxm = params.lxm ?? undefined;
    const jti = await crypto.randomStr(16, 'hex');
    const header = {
        typ: 'JWT',
        alg: keypair.jwtAlg,
    };
    const payload = common.noUndefinedVals({
        iat,
        iss,
        aud,
        exp,
        lxm,
        jti,
    });
    const toSignStr = `${jsonToB64Url(header)}.${jsonToB64Url(payload)}`;
    const toSign = ui8.fromString(toSignStr, 'utf8');
    const sig = await keypair.sign(toSign);
    return `${toSignStr}.${ui8.toString(sig, 'base64url')}`;
};
exports.createServiceJwt = createServiceJwt;
const createServiceAuthHeaders = async (params) => {
    const jwt = await (0, exports.createServiceJwt)(params);
    return {
        headers: { authorization: `Bearer ${jwt}` },
    };
};
exports.createServiceAuthHeaders = createServiceAuthHeaders;
const jsonToB64Url = (json) => {
    return common.utf8ToB64Url(JSON.stringify(json));
};
const verifyJwt = async (jwtStr, ownDid, // null indicates to skip the audience check
lxm, // null indicates to skip the lxm check
getSigningKey) => {
    const parts = jwtStr.split('.');
    if (parts.length !== 3) {
        throw new types_1.AuthRequiredError('poorly formatted jwt', 'BadJwt');
    }
    const header = parseHeader(parts[0]);
    // The spec does not describe what to do with the "typ" claim. We can,
    // however, forbid some values that are not compatible with our use case.
    if (
    // service tokens are not OAuth 2.0 access tokens
    // https://datatracker.ietf.org/doc/html/rfc9068
    header['typ'] === 'at+jwt' ||
        // "refresh+jwt" is a non-standard type used by the @atproto packages
        header['typ'] === 'refresh+jwt' ||
        // "DPoP" proofs are not meant to be used as service tokens
        // https://datatracker.ietf.org/doc/html/rfc9449
        header['typ'] === 'dpop+jwt') {
        throw new types_1.AuthRequiredError(`Invalid jwt type "${header['typ']}"`, 'BadJwtType');
    }
    const payload = parsePayload(parts[1]);
    const sig = parts[2];
    if (Date.now() / 1000 > payload.exp) {
        throw new types_1.AuthRequiredError('jwt expired', 'JwtExpired');
    }
    if (ownDid !== null && payload.aud !== ownDid) {
        throw new types_1.AuthRequiredError('jwt audience does not match service did', 'BadJwtAudience');
    }
    if (lxm !== null && payload.lxm !== lxm) {
        throw new types_1.AuthRequiredError(payload.lxm !== undefined
            ? `bad jwt lexicon method ("lxm"). must match: ${lxm}`
            : `missing jwt lexicon method ("lxm"). must match: ${lxm}`, 'BadJwtLexiconMethod');
    }
    const msgBytes = ui8.fromString(parts.slice(0, 2).join('.'), 'utf8');
    const sigBytes = ui8.fromString(sig, 'base64url');
    const verifySignatureWithKey = async (key) => {
        return crypto.verifySignature(key, msgBytes, sigBytes, {
            jwtAlg: header.alg,
            allowMalleableSig: true,
        });
    };
    const signingKey = await getSigningKey(payload.iss, false);
    let validSig;
    try {
        validSig = await verifySignatureWithKey(signingKey);
    }
    catch (err) {
        throw new types_1.AuthRequiredError('could not verify jwt signature', 'BadJwtSignature');
    }
    if (!validSig) {
        // get fresh signing key in case it failed due to a recent rotation
        const freshSigningKey = await getSigningKey(payload.iss, true);
        try {
            validSig =
                freshSigningKey !== signingKey
                    ? await verifySignatureWithKey(freshSigningKey)
                    : false;
        }
        catch (err) {
            throw new types_1.AuthRequiredError('could not verify jwt signature', 'BadJwtSignature');
        }
    }
    if (!validSig) {
        throw new types_1.AuthRequiredError('jwt signature does not match jwt issuer', 'BadJwtSignature');
    }
    return payload;
};
exports.verifyJwt = verifyJwt;
const parseB64UrlToJson = (b64) => {
    return JSON.parse(common.b64UrlToUtf8(b64));
};
const parseHeader = (b64) => {
    const header = parseB64UrlToJson(b64);
    if (!header || typeof header !== 'object' || typeof header.alg !== 'string') {
        throw new types_1.AuthRequiredError('poorly formatted jwt', 'BadJwt');
    }
    return header;
};
const parsePayload = (b64) => {
    const payload = parseB64UrlToJson(b64);
    if (!payload ||
        typeof payload !== 'object' ||
        typeof payload.iss !== 'string' ||
        typeof payload.aud !== 'string' ||
        typeof payload.exp !== 'number' ||
        (payload.lxm && typeof payload.lxm !== 'string') ||
        (payload.nonce && typeof payload.nonce !== 'string')) {
        throw new types_1.AuthRequiredError('poorly formatted jwt', 'BadJwt');
    }
    return payload;
};
//# sourceMappingURL=auth.js.map