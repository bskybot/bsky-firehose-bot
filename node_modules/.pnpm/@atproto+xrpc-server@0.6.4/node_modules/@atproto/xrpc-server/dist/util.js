"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseReqNsid = exports.ServerTimer = exports.serverTimingHeader = exports.createDecoder = exports.parseContentEncoding = exports.createDecoders = exports.processBodyAsBytes = exports.normalizeMime = exports.validateOutput = exports.validateInput = exports.getQueryParams = exports.decodeQueryParam = exports.decodeQueryParams = void 0;
const node_assert_1 = __importDefault(require("node:assert"));
const node_stream_1 = require("node:stream");
const zlib = __importStar(require("node:zlib"));
const mime_types_1 = __importDefault(require("mime-types"));
const lexicon_1 = require("@atproto/lexicon");
const common_1 = require("@atproto/common");
const xrpc_1 = require("@atproto/xrpc");
const types_1 = require("./types");
function decodeQueryParams(def, params) {
    const decoded = {};
    for (const k in params) {
        const val = params[k];
        const property = def.parameters?.properties?.[k];
        if (property) {
            if (property.type === 'array') {
                const vals = [];
                decoded[k] = val
                    ? vals
                        .concat(val) // Cast to array
                        .flatMap((v) => decodeQueryParam(property.items.type, v) ?? [])
                    : undefined;
            }
            else {
                decoded[k] = decodeQueryParam(property.type, val);
            }
        }
    }
    return decoded;
}
exports.decodeQueryParams = decodeQueryParams;
function decodeQueryParam(type, value) {
    if (!value) {
        return undefined;
    }
    if (type === 'string' || type === 'datetime') {
        return String(value);
    }
    if (type === 'float') {
        return Number(String(value));
    }
    else if (type === 'integer') {
        return parseInt(String(value), 10) || 0;
    }
    else if (type === 'boolean') {
        return value === 'true';
    }
}
exports.decodeQueryParam = decodeQueryParam;
function getQueryParams(url = '') {
    const { searchParams } = new URL(url ?? '', 'http://x');
    const result = {};
    for (const key of searchParams.keys()) {
        result[key] = searchParams.getAll(key);
        if (result[key].length === 1) {
            result[key] = result[key][0];
        }
    }
    return result;
}
exports.getQueryParams = getQueryParams;
function validateInput(nsid, def, req, opts, lexicons) {
    // request expectation
    const bodyPresence = getBodyPresence(req);
    if (bodyPresence === 'present' && (def.type !== 'procedure' || !def.input)) {
        throw new types_1.InvalidRequestError(`A request body was provided when none was expected`);
    }
    if (def.type === 'query') {
        return;
    }
    if (bodyPresence === 'missing' && def.input) {
        throw new types_1.InvalidRequestError(`A request body is expected but none was provided`);
    }
    // mimetype
    const inputEncoding = normalizeMime(req.headers['content-type'] || '');
    if (def.input?.encoding &&
        (!inputEncoding || !isValidEncoding(def.input?.encoding, inputEncoding))) {
        if (!inputEncoding) {
            throw new types_1.InvalidRequestError(`Request encoding (Content-Type) required but not provided`);
        }
        else {
            throw new types_1.InvalidRequestError(`Wrong request encoding (Content-Type): ${inputEncoding}`);
        }
    }
    if (!inputEncoding) {
        // no input body
        return undefined;
    }
    // if input schema, validate
    if (def.input?.schema) {
        try {
            const lexBody = req.body ? (0, lexicon_1.jsonToLex)(req.body) : req.body;
            req.body = lexicons.assertValidXrpcInput(nsid, lexBody);
        }
        catch (e) {
            throw new types_1.InvalidRequestError(e instanceof Error ? e.message : String(e));
        }
    }
    // if middleware already got the body, we pass that along as input
    // otherwise, we pass along a decoded readable stream
    let body;
    if (req.readableEnded) {
        body = req.body;
    }
    else {
        body = decodeBodyStream(req, opts.blobLimit);
    }
    return {
        encoding: inputEncoding,
        body,
    };
}
exports.validateInput = validateInput;
function validateOutput(nsid, def, output, lexicons) {
    // initial validation
    if (output) {
        types_1.handlerSuccess.parse(output);
    }
    // response expectation
    if (output?.body && !def.output) {
        throw new types_1.InternalServerError(`A response body was provided when none was expected`);
    }
    if (!output?.body && def.output) {
        throw new types_1.InternalServerError(`A response body is expected but none was provided`);
    }
    // mimetype
    if (def.output?.encoding &&
        (!output?.encoding ||
            !isValidEncoding(def.output?.encoding, output?.encoding))) {
        throw new types_1.InternalServerError(`Invalid response encoding: ${output?.encoding}`);
    }
    // output schema
    if (def.output?.schema) {
        try {
            const result = lexicons.assertValidXrpcOutput(nsid, output?.body);
            if (output) {
                output.body = result;
            }
        }
        catch (e) {
            throw new types_1.InternalServerError(e instanceof Error ? e.message : String(e));
        }
    }
    return output;
}
exports.validateOutput = validateOutput;
function normalizeMime(v) {
    if (!v)
        return false;
    const fullType = mime_types_1.default.contentType(v);
    if (!fullType)
        return false;
    const shortType = fullType.split(';')[0];
    if (!shortType)
        return false;
    return shortType;
}
exports.normalizeMime = normalizeMime;
function isValidEncoding(possibleStr, value) {
    const possible = possibleStr.split(',').map((v) => v.trim());
    const normalized = normalizeMime(value);
    if (!normalized)
        return false;
    if (possible.includes('*/*'))
        return true;
    return possible.includes(normalized);
}
function getBodyPresence(req) {
    if (req.headers['transfer-encoding'] != null)
        return 'present';
    if (req.headers['content-length'] === '0')
        return 'empty';
    if (req.headers['content-length'] != null)
        return 'present';
    return 'missing';
}
function processBodyAsBytes(req) {
    return new Promise((resolve) => {
        const chunks = [];
        req.on('data', (chunk) => chunks.push(chunk));
        req.on('end', () => resolve(new Uint8Array(Buffer.concat(chunks))));
    });
}
exports.processBodyAsBytes = processBodyAsBytes;
function decodeBodyStream(req, maxSize) {
    const contentEncoding = req.headers['content-encoding'];
    const contentLength = req.headers['content-length'];
    const contentLengthParsed = contentLength
        ? parseInt(contentLength, 10)
        : undefined;
    if (Number.isNaN(contentLengthParsed)) {
        throw new types_1.XRPCError(xrpc_1.ResponseType.InvalidRequest, 'invalid content-length');
    }
    if (maxSize !== undefined &&
        contentLengthParsed !== undefined &&
        contentLengthParsed > maxSize) {
        throw new types_1.XRPCError(xrpc_1.ResponseType.PayloadTooLarge, 'request entity too large');
    }
    const transforms = createDecoders(contentEncoding);
    if (maxSize !== undefined) {
        const maxSizeChecker = new common_1.MaxSizeChecker(maxSize, () => new types_1.XRPCError(xrpc_1.ResponseType.PayloadTooLarge, 'request entity too large'));
        transforms.push(maxSizeChecker);
    }
    return transforms.length > 0
        ? (0, node_stream_1.pipeline)([req, ...transforms], () => { })
        : req;
}
function createDecoders(contentEncoding) {
    return parseContentEncoding(contentEncoding).reverse().map(createDecoder);
}
exports.createDecoders = createDecoders;
function parseContentEncoding(contentEncoding) {
    // undefined, empty string, and empty array
    if (!contentEncoding?.length)
        return [];
    // Non empty string
    if (typeof contentEncoding === 'string') {
        return contentEncoding
            .split(',')
            .map((x) => x.trim().toLowerCase())
            .filter((x) => x && x !== 'identity');
    }
    // content-encoding should never be an array
    return contentEncoding.flatMap(parseContentEncoding);
}
exports.parseContentEncoding = parseContentEncoding;
function createDecoder(encoding) {
    // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
    // > All content-coding values are case-insensitive...
    switch (encoding.trim().toLowerCase()) {
        // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
        case 'gzip':
        case 'x-gzip':
            return zlib.createGunzip({
                // using Z_SYNC_FLUSH (cURL default) to be less strict when decoding
                flush: zlib.constants.Z_SYNC_FLUSH,
                finishFlush: zlib.constants.Z_SYNC_FLUSH,
            });
        case 'deflate':
            return zlib.createInflate();
        case 'br':
            return zlib.createBrotliDecompress();
        case 'identity':
            return new node_stream_1.PassThrough();
        default:
            throw new types_1.XRPCError(xrpc_1.ResponseType.UnsupportedMediaType, 'unsupported content-encoding');
    }
}
exports.createDecoder = createDecoder;
function serverTimingHeader(timings) {
    return timings
        .map((timing) => {
        let header = timing.name;
        if (timing.duration)
            header += `;dur=${timing.duration}`;
        if (timing.description)
            header += `;desc="${timing.description}"`;
        return header;
    })
        .join(', ');
}
exports.serverTimingHeader = serverTimingHeader;
class ServerTimer {
    constructor(name, description) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: description
        });
        Object.defineProperty(this, "duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    start() {
        this.startMs = Date.now();
        return this;
    }
    stop() {
        (0, node_assert_1.default)(this.startMs, "timer hasn't been started");
        this.duration = Date.now() - this.startMs;
        return this;
    }
}
exports.ServerTimer = ServerTimer;
const parseReqNsid = (req) => {
    const originalUrl = ('originalUrl' in req && req.originalUrl) || req.url || '/';
    const nsid = originalUrl.split('?')[0].replace('/xrpc/', '');
    return nsid.endsWith('/') ? nsid.slice(0, -1) : nsid; // trim trailing slash
};
exports.parseReqNsid = parseReqNsid;
//# sourceMappingURL=util.js.map