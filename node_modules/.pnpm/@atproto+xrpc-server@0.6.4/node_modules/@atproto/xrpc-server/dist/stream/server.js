"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrpcStreamServer = void 0;
const ws_1 = require("ws");
const frames_1 = require("./frames");
const logger_1 = __importDefault(require("./logger"));
const types_1 = require("./types");
class XrpcStreamServer {
    constructor(opts) {
        Object.defineProperty(this, "wss", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { handler, ...serverOpts } = opts;
        this.wss = new ws_1.WebSocketServer(serverOpts);
        this.wss.on('connection', async (socket, req) => {
            socket.on('error', (err) => logger_1.default.error(err, 'websocket error'));
            try {
                const ac = new AbortController();
                const iterator = unwrapIterator(handler(req, ac.signal, socket, this));
                socket.once('close', () => {
                    iterator.return?.();
                    ac.abort();
                });
                const safeFrames = wrapIterator(iterator);
                for await (const frame of safeFrames) {
                    await new Promise((res, rej) => {
                        socket.send(frame.toBytes(), { binary: true }, (err) => {
                            // @TODO this callback may give more aggressive on backpressure than
                            // we ultimately want, but trying it out for the time being.
                            if (err)
                                return rej(err);
                            res(undefined);
                        });
                    });
                    if (frame instanceof frames_1.ErrorFrame) {
                        throw new types_1.DisconnectError(types_1.CloseCode.Policy, frame.body.error);
                    }
                }
            }
            catch (err) {
                if (err instanceof types_1.DisconnectError) {
                    return socket.close(err.wsCode, err.xrpcCode);
                }
                else {
                    logger_1.default.error(err, 'websocket server error');
                    return socket.terminate();
                }
            }
            socket.close(types_1.CloseCode.Normal);
        });
    }
}
exports.XrpcStreamServer = XrpcStreamServer;
function unwrapIterator(iterable) {
    return iterable[Symbol.asyncIterator]();
}
function wrapIterator(iterator) {
    return {
        [Symbol.asyncIterator]() {
            return iterator;
        },
    };
}
//# sourceMappingURL=server.js.map