"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = exports.createServer = void 0;
const stream_1 = require("stream");
const express_1 = __importDefault(require("express"));
const lexicon_1 = require("@atproto/lexicon");
const common_1 = require("@atproto/common");
const stream_2 = require("./stream");
const types_1 = require("./types");
const util_1 = require("./util");
const logger_1 = __importDefault(require("./logger"));
const rate_limiter_1 = require("./rate-limiter");
function createServer(lexicons, options) {
    return new Server(lexicons, options);
}
exports.createServer = createServer;
class Server {
    constructor(lexicons, opts) {
        Object.defineProperty(this, "router", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, express_1.default)()
        });
        Object.defineProperty(this, "routes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: express_1.default.Router()
        });
        Object.defineProperty(this, "subscriptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "lex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new lexicon_1.Lexicons()
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "middleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "globalRateLimiters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sharedRateLimiters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "routeRateLimiterFns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (lexicons) {
            this.addLexicons(lexicons);
        }
        this.router.use(this.routes);
        this.router.use('/xrpc/:methodId', this.catchall.bind(this));
        this.router.use(errorMiddleware);
        this.router.once('mount', (app) => {
            this.enableStreamingOnListen(app);
        });
        this.options = opts ?? {};
        this.middleware = {
            json: express_1.default.json({ limit: opts?.payload?.jsonLimit }),
            text: express_1.default.text({ limit: opts?.payload?.textLimit }),
        };
        this.globalRateLimiters = [];
        this.sharedRateLimiters = {};
        this.routeRateLimiterFns = {};
        if (opts?.rateLimits?.global) {
            for (const limit of opts.rateLimits.global) {
                const rateLimiter = opts.rateLimits.creator({
                    ...limit,
                    keyPrefix: `rl-${limit.name}`,
                });
                this.globalRateLimiters.push(rateLimiter);
            }
        }
        if (opts?.rateLimits?.shared) {
            for (const limit of opts.rateLimits.shared) {
                const rateLimiter = opts.rateLimits.creator({
                    ...limit,
                    keyPrefix: `rl-${limit.name}`,
                });
                this.sharedRateLimiters[limit.name] = rateLimiter;
            }
        }
    }
    // handlers
    // =
    method(nsid, configOrFn) {
        this.addMethod(nsid, configOrFn);
    }
    addMethod(nsid, configOrFn) {
        const config = typeof configOrFn === 'function' ? { handler: configOrFn } : configOrFn;
        const def = this.lex.getDef(nsid);
        if (def?.type === 'query' || def?.type === 'procedure') {
            this.addRoute(nsid, def, config);
        }
        else {
            throw new Error(`Lex def for ${nsid} is not a query or a procedure`);
        }
    }
    streamMethod(nsid, configOrFn) {
        this.addStreamMethod(nsid, configOrFn);
    }
    addStreamMethod(nsid, configOrFn) {
        const config = typeof configOrFn === 'function' ? { handler: configOrFn } : configOrFn;
        const def = this.lex.getDef(nsid);
        if (def?.type === 'subscription') {
            this.addSubscription(nsid, def, config);
        }
        else {
            throw new Error(`Lex def for ${nsid} is not a subscription`);
        }
    }
    // schemas
    // =
    addLexicon(doc) {
        this.lex.add(doc);
    }
    addLexicons(docs) {
        for (const doc of docs) {
            this.addLexicon(doc);
        }
    }
    // http
    // =
    async addRoute(nsid, def, config) {
        const verb = def.type === 'procedure' ? 'post' : 'get';
        const middleware = [];
        middleware.push(createLocalsMiddleware(nsid));
        if (config.auth) {
            middleware.push(createAuthMiddleware(config.auth));
        }
        if (verb === 'post') {
            middleware.push(this.middleware.json);
            middleware.push(this.middleware.text);
        }
        this.setupRouteRateLimits(nsid, config);
        this.routes[verb](`/xrpc/${nsid}`, ...middleware, this.createHandler(nsid, def, config));
    }
    async catchall(req, res, next) {
        if (this.globalRateLimiters) {
            try {
                const rlRes = await (0, rate_limiter_1.consumeMany)({
                    req,
                    res,
                    auth: undefined,
                    params: {},
                    input: undefined,
                }, this.globalRateLimiters.map((rl) => (ctx) => rl.consume(ctx)));
                if (rlRes instanceof types_1.RateLimitExceededError) {
                    return next(rlRes);
                }
            }
            catch (err) {
                return next(err);
            }
        }
        if (this.options.catchall) {
            return this.options.catchall(req, res, next);
        }
        const def = this.lex.getDef(req.params.methodId);
        if (!def) {
            return next(new types_1.MethodNotImplementedError());
        }
        // validate method
        if (def.type === 'query' && req.method !== 'GET') {
            return next(new types_1.InvalidRequestError(`Incorrect HTTP method (${req.method}) expected GET`));
        }
        else if (def.type === 'procedure' && req.method !== 'POST') {
            return next(new types_1.InvalidRequestError(`Incorrect HTTP method (${req.method}) expected POST`));
        }
        return next();
    }
    createHandler(nsid, def, routeCfg) {
        const routeOpts = {
            blobLimit: routeCfg.opts?.blobLimit ?? this.options.payload?.blobLimit,
        };
        const validateReqInput = (req) => (0, util_1.validateInput)(nsid, def, req, routeOpts, this.lex);
        const validateResOutput = this.options.validateResponse === false
            ? (output) => output
            : (output) => (0, util_1.validateOutput)(nsid, def, output, this.lex);
        const assertValidXrpcParams = (params) => this.lex.assertValidXrpcParams(nsid, params);
        const rlFns = this.routeRateLimiterFns[nsid] ?? [];
        const consumeRateLimit = (reqCtx) => (0, rate_limiter_1.consumeMany)(reqCtx, rlFns);
        return async function (req, res, next) {
            try {
                // validate request
                let params = (0, util_1.decodeQueryParams)(def, req.query);
                try {
                    params = assertValidXrpcParams(params);
                }
                catch (e) {
                    throw new types_1.InvalidRequestError(String(e));
                }
                const input = validateReqInput(req);
                const locals = req[kRequestLocals];
                const reqCtx = {
                    params,
                    input,
                    auth: locals.auth,
                    req,
                    res,
                };
                // handle rate limits
                const result = await consumeRateLimit(reqCtx);
                if (result instanceof types_1.RateLimitExceededError) {
                    return next(result);
                }
                // run the handler
                const outputUnvalidated = await routeCfg.handler(reqCtx);
                if ((0, types_1.isHandlerError)(outputUnvalidated)) {
                    throw types_1.XRPCError.fromError(outputUnvalidated);
                }
                if (outputUnvalidated && isHandlerPipeThrough(outputUnvalidated)) {
                    // set headers
                    if (outputUnvalidated?.headers) {
                        Object.entries(outputUnvalidated.headers).forEach(([name, val]) => {
                            res.header(name, val);
                        });
                    }
                    res
                        .header('Content-Type', outputUnvalidated.encoding)
                        .status(200)
                        .send(Buffer.from(outputUnvalidated.buffer));
                    return;
                }
                if (!outputUnvalidated || isHandlerSuccess(outputUnvalidated)) {
                    // validate response
                    const output = validateResOutput(outputUnvalidated);
                    // set headers
                    if (output?.headers) {
                        Object.entries(output.headers).forEach(([name, val]) => {
                            res.header(name, val);
                        });
                    }
                    // send response
                    if (output?.encoding === 'application/json' ||
                        output?.encoding === 'json') {
                        const json = (0, lexicon_1.lexToJson)(output.body);
                        res.status(200).json(json);
                    }
                    else if (output?.body instanceof stream_1.Readable) {
                        res.header('Content-Type', output.encoding);
                        res.status(200);
                        res.once('error', (err) => res.destroy(err));
                        (0, common_1.forwardStreamErrors)(output.body, res);
                        output.body.pipe(res);
                    }
                    else if (output) {
                        res
                            .header('Content-Type', output.encoding)
                            .status(200)
                            .send(output.body instanceof Uint8Array
                            ? Buffer.from(output.body)
                            : output.body);
                    }
                    else {
                        res.status(200).end();
                    }
                }
            }
            catch (err) {
                // Express will not call the next middleware (errorMiddleware in this case)
                // if the value passed to next is false-y (e.g. null, undefined, 0).
                // Hence we replace it with an InternalServerError.
                if (!err) {
                    next(new types_1.InternalServerError());
                }
                else {
                    next(err);
                }
            }
        };
    }
    async addSubscription(nsid, def, config) {
        const assertValidXrpcParams = (params) => this.lex.assertValidXrpcParams(nsid, params);
        this.subscriptions.set(nsid, new stream_2.XrpcStreamServer({
            noServer: true,
            handler: async function* (req, signal) {
                try {
                    // authenticate request
                    const auth = await config.auth?.({ req });
                    if ((0, types_1.isHandlerError)(auth)) {
                        throw types_1.XRPCError.fromError(auth);
                    }
                    // validate request
                    let params = (0, util_1.decodeQueryParams)(def, (0, util_1.getQueryParams)(req.url));
                    try {
                        params = assertValidXrpcParams(params);
                    }
                    catch (e) {
                        throw new types_1.InvalidRequestError(String(e));
                    }
                    // stream
                    const items = config.handler({ req, params, auth, signal });
                    for await (const item of items) {
                        if (item instanceof stream_2.Frame) {
                            yield item;
                            continue;
                        }
                        const type = item?.['$type'];
                        if (!common_1.check.is(item, common_1.schema.map) || typeof type !== 'string') {
                            yield new stream_2.MessageFrame(item);
                            continue;
                        }
                        const split = type.split('#');
                        let t;
                        if (split.length === 2 &&
                            (split[0] === '' || split[0] === nsid)) {
                            t = `#${split[1]}`;
                        }
                        else {
                            t = type;
                        }
                        const clone = { ...item };
                        delete clone['$type'];
                        yield new stream_2.MessageFrame(clone, { type: t });
                    }
                }
                catch (err) {
                    const xrpcErrPayload = types_1.XRPCError.fromError(err).payload;
                    yield new stream_2.ErrorFrame({
                        error: xrpcErrPayload.error ?? 'Unknown',
                        message: xrpcErrPayload.message,
                    });
                }
            },
        }));
    }
    enableStreamingOnListen(app) {
        const _listen = app.listen;
        app.listen = (...args) => {
            // @ts-ignore the args spread
            const httpServer = _listen.call(app, ...args);
            httpServer.on('upgrade', (req, socket, head) => {
                const url = new URL(req.url || '', 'http://x');
                const sub = url.pathname.startsWith('/xrpc/')
                    ? this.subscriptions.get(url.pathname.replace('/xrpc/', ''))
                    : undefined;
                if (!sub)
                    return socket.destroy();
                sub.wss.handleUpgrade(req, socket, head, (ws) => sub.wss.emit('connection', ws, req));
            });
            return httpServer;
        };
    }
    setupRouteRateLimits(nsid, config) {
        this.routeRateLimiterFns[nsid] = [];
        for (const limit of this.globalRateLimiters) {
            const consumeFn = async (ctx) => {
                return limit.consume(ctx);
            };
            this.routeRateLimiterFns[nsid].push(consumeFn);
        }
        if (config.rateLimit) {
            const limits = Array.isArray(config.rateLimit)
                ? config.rateLimit
                : [config.rateLimit];
            this.routeRateLimiterFns[nsid] = [];
            for (let i = 0; i < limits.length; i++) {
                const limit = limits[i];
                const { calcKey, calcPoints } = limit;
                if ((0, types_1.isShared)(limit)) {
                    const rateLimiter = this.sharedRateLimiters[limit.name];
                    if (rateLimiter) {
                        const consumeFn = (ctx) => rateLimiter.consume(ctx, {
                            calcKey,
                            calcPoints,
                        });
                        this.routeRateLimiterFns[nsid].push(consumeFn);
                    }
                }
                else {
                    const { durationMs, points } = limit;
                    const rateLimiter = this.options.rateLimits?.creator({
                        keyPrefix: `nsid-${i}`,
                        durationMs,
                        points,
                        calcKey,
                        calcPoints,
                    });
                    if (rateLimiter) {
                        this.sharedRateLimiters[nsid] = rateLimiter;
                        const consumeFn = (ctx) => rateLimiter.consume(ctx, {
                            calcKey,
                            calcPoints,
                        });
                        this.routeRateLimiterFns[nsid].push(consumeFn);
                    }
                }
            }
        }
    }
}
exports.Server = Server;
function isHandlerSuccess(v) {
    return types_1.handlerSuccess.safeParse(v).success;
}
function isHandlerPipeThrough(v) {
    if (v === null || typeof v !== 'object') {
        return false;
    }
    if (!isString(v['encoding']) || !(v['buffer'] instanceof ArrayBuffer)) {
        return false;
    }
    if (v['headers'] !== undefined) {
        if (v['headers'] === null || typeof v['headers'] !== 'object') {
            return false;
        }
        if (!Object.values(v['headers']).every(isString)) {
            return false;
        }
    }
    return true;
}
const isString = (val) => typeof val === 'string';
const kRequestLocals = Symbol('requestLocals');
function createLocalsMiddleware(nsid) {
    return function (req, _res, next) {
        const locals = { auth: undefined, nsid };
        req[kRequestLocals] = locals;
        return next();
    };
}
function createAuthMiddleware(verifier) {
    return async function (req, res, next) {
        try {
            const result = await verifier({ req, res });
            if ((0, types_1.isHandlerError)(result)) {
                throw types_1.XRPCError.fromError(result);
            }
            const locals = req[kRequestLocals];
            locals.auth = result;
            next();
        }
        catch (err) {
            next(err);
        }
    };
}
const errorMiddleware = function (err, req, res, next) {
    const locals = req[kRequestLocals];
    const methodSuffix = locals ? ` method ${locals.nsid}` : '';
    const xrpcError = types_1.XRPCError.fromError(err);
    if (xrpcError instanceof types_1.InternalServerError) {
        // log trace for unhandled exceptions
        logger_1.default.error(err, `unhandled exception in xrpc${methodSuffix}`);
    }
    else {
        // do not log trace for known xrpc errors
        logger_1.default.error({
            status: xrpcError.type,
            message: xrpcError.message,
            name: xrpcError.customErrorName,
        }, `error in xrpc${methodSuffix}`);
    }
    if (res.headersSent) {
        return next(err);
    }
    return res.status(xrpcError.type).json(xrpcError.payload);
};
//# sourceMappingURL=server.js.map